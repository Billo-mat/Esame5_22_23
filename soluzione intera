import pandas as pd

# 1. Caricamento del dataset
# Usiamo index_col=0 per impostare la prima colonna come indice
df_pigs = pd.read_csv('pigs.csv', index_col=0)

# 2. Creazione della colonna booleana 'pig_sighting'
# DETECTED = 1 indica un avvistamento (True)
# DETECTED = 0 indica una posizione casuale (False)
df_pigs['pig_sighting'] = df_pigs['DETECTED'] == 1

# Visualizzazione delle prime righe per verifica
print(df_pigs)

import pandas as pd
import matplotlib.pyplot as plt

# 1. Caricamento del dataset
df_pigs = pd.read_csv('pigs.csv', index_col=0)

# 2. Definizione delle colonne relative ai confini
border_cols = ['borderMI', 'borderNY', 'borderQC']

# 3. Creazione della figura
plt.figure(figsize=(10, 6))

# 4. Generazione degli istogrammi
# Usiamo un ciclo per sovrapporre i tre istogrammi con una certa trasparenza (alpha)
for col in border_cols:
    plt.hist(df_pigs[col], bins=30, alpha=0.5, label=col)

# 5. Aggiunta di titolo, etichette e legenda
plt.title('Distribution of Distances from Borders')
plt.xlabel('Distance (meters)')
plt.ylabel('Frequency')
plt.legend(title='Borders')

# 6. Griglia e salvataggio
plt.grid(axis='y', linestyle='--', alpha=0.7)
plt.show()


import math

def area(r1: float, r2: float, r3: float) -> float:
    """
    Seleziona il raggio massimo tra tre (in metri) e restituisce l'area 
    del cerchio in chilometri quadrati.

    >>> area(1000.0, 2000.0, 3000.0)
    28.274333882308138
    """
    # 1. Trova il raggio massimo in metri
    max_r_m = max(r1, r2, r3)
    
    # 2. Converti il raggio in chilometri
    r_km = max_r_m / 1000.0
    
    # 3. Calcola l'area: pi * r^2
    return math.pi * (r_km ** 2)

# Per verificare il test:
if __name__ == "__main__":
    import doctest
    doctest.testmod()

    
df_pigs['area'] = df_pigs.apply(
    lambda row: area(row['borderMI'], row['borderNY'], row['borderQC']), 
    axis=1
)

# Visualizzazione delle prime righe per conferma
print(df_pigs)


import pandas as pd

# 1. Caricamento del dataset
df_pigs = pd.read_csv('pigs.csv', index_col=0)

# 2. Filtriamo solo per i siti con avvistamento (DETECTED == 1)
sighting_df = df_pigs[df_pigs['DETECTED'] == 1].copy()

# 3. Definiamo i due gruppi
# Wild Boar: tipo specifico
wild_boars = sighting_df[sighting_df['PigType'] == 'wild boar']

# Domesticated: usiamo .str.contains per includere "domesticated" e "domesticated - pot bellied"
domesticated = sighting_df[sighting_df['PigType'].str.contains('domesticated', case=False, na=False)]

# 4. Calcolo e stampa delle medie
print("--- Wild Boars (Sightings) ---")
print(f"Mean dist_boar: {wild_boars['dist_boar'].mean():.2f} m")
print(f"Mean dist_pig:  {wild_boars['dist_pig'].mean():.2f} m\n")

print("--- Domesticated (Sightings) ---")
print(f"Mean dist_boar: {domesticated['dist_boar'].mean():.2f} m")
print(f"Mean dist_pig:  {domesticated['dist_pig'].mean():.2f} m")


sampled_pigs = wild_boars.sample(5)

# 4. Ordinamento per dist_pig in ordine crescente
sorted_sample = sampled_pigs.sort_values(by='dist_pig', ascending=True)

# 5. Stampa del risultato (colonna borderMI)
print("Valori di borderMI per i 5 cinghiali campionati (ordinati per dist_pig crescente):")
print(sorted_sample['borderMI'])


import pandas as pd
import pymc as pm
import arviz as az

# 1. Caricamento e filtraggio dei dati
df_pigs = pd.read_csv('pigs.csv', index_col=0)

# Selezioniamo solo i valori di borderQC per i cinghiali selvatici
wild_boar_qc = df_pigs[df_pigs['PigType'] == 'wild boar']['borderQC'].values

# 2. Definizione del modello statistico con PyMC
with pm.Model() as model:
    # PRIOR: Media mu distribuita Normalmente
    # mu ~ Normal(mean=170000, sigma=100000)
    mu = pm.Normal('mu', mu=170000, sigma=100000)
    
    # PRIOR: Deviazione standard sigma distribuita Esponenzialmente
    # sigma ~ Exponential(lambda=1)
    sigma = pm.Exponential('sigma', lam=1)
    
    # LIKELIHOOD: La distanza osservata segue una distribuzione Normale
    # borderQC ~ Normal(mu, sigma)
    y_obs = pm.Normal('y_obs', mu=mu, sigma=sigma, observed=wild_boar_qc)
    
    # 3. Campionamento
    # Eseguiamo l'inferenza per ottenere la distribuzione a posteriori
    trace = pm.sample(2000, tune=1000, chains=2, return_inferencedata=True)

# 4. Risultati
# Stampiamo il sommario statistico della stima
summary = az.summary(trace)
print(summary)
